{"version":3,"sources":["library.js","gameOfLife.js","App.js","serviceWorker.js","index.js"],"names":["generateDeadCells","length","Array","fill","generateGrid","height","board","count","push","getNeighboursByIndex","inputArray","index","neighbours","filter","x","undefined","getVerticalNeighbours","arrayIndex","subArrayIndex","topNeighbours","bottomNeighbours","getAllNeighbours","toString","split","map","sort","countAliveNeighboursOfCell","isAlive","aliveNeighbours","currentState","toggleState","result","slice","filterValidGeneration","bounds","currGeneration","isValid","elem","topLeft","this","bottomRight","checkValidHeight","bind","checkValidWidth","subArray","module","exports","repeat","symbol","join","getHorizontalNeighbours","runIteration","forEach","elemOfArray","totalAlive","state","world","resurrectCells","subIndex","getCoordOfAliveCells","validateInput","bound","aliveCellsCoordinate","_this3","number","_this4","validateOutput","_this","_this2","require","nextGeneration","heightOfWorld","lengthOfWorld","GameOfLife","props","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","currentGeneration","previousGen","nextGen","assertThisInitialized","grid","interval","currentCell","cell","JSON","parse","includes","position","indexOf","splice","e","target","id","color","cellStyle","document","getElementById","style","backgroundColor","updateCurrentGeneration","row","currentRow","column","ids","react_default","a","createElement","onClick","makeCellAlive","table","createRow","ele","stringify","clearPreviousCellsStyling","console","log","setInterval","setState","updateCellsOnBoard","clearInterval","clearCurrentCellsStyling","window","location","className","createTable","startGame","resetGame","aboutGame","Component","Boolean","hostname","match","ReactDOM","render","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.760bd61a.chunk.js","sourcesContent":["const repeat = function(symbol, length) {\n  return new Array(length).fill(symbol).join(\"\");\n};\n\nconst generateDeadCells = function(length) {\n  return new Array(length).fill(0);\n};\n\nconst generateGrid = function(height, length) {\n  let board = [];\n  for (let count = 0; count < height; count++) {\n    board.push(generateDeadCells(length));\n  }\n  return board;\n};\n\nconst getNeighboursByIndex = function(inputArray, index) {\n  let neighbours = [];\n  if (index < 0) {\n    return neighbours;\n  }\n  neighbours.push(inputArray[index - 1]);\n  neighbours.push(inputArray[index + 1]);\n  return neighbours.filter(x => x !== undefined);\n};\n\nconst getHorizontalNeighbours = function(\n  inputArray,\n  arrayIndex,\n  subArrayIndex\n) {\n  return getNeighboursByIndex(inputArray[arrayIndex], subArrayIndex);\n};\n\nconst getVerticalNeighbours = function(inputArray, arrayIndex, subArrayIndex) {\n  let neighbours = [];\n  let topNeighbours = inputArray[arrayIndex - 1];\n  let bottomNeighbours = inputArray[arrayIndex + 1];\n\n  if (inputArray[1] === undefined) {\n    return neighbours;\n  }\n  if (topNeighbours !== undefined) {\n    neighbours.push(topNeighbours[subArrayIndex]);\n  }\n\n  if (bottomNeighbours !== undefined) {\n    neighbours.push(bottomNeighbours[subArrayIndex]);\n  }\n\n  return neighbours;\n};\n\nconst getAllNeighbours = function(inputArray, arrayIndex, subArrayIndex) {\n  let neighbours = [];\n  if (arrayIndex < 0 || subArrayIndex < 0 || inputArray.length < 2) {\n    return neighbours;\n  }\n\n  // horizontal neighbours\n  neighbours.push(getNeighboursByIndex(inputArray[arrayIndex], subArrayIndex));\n\n  // top diagonal neighbours\n  if (inputArray[arrayIndex - 1] !== undefined) {\n    neighbours.push(\n      getNeighboursByIndex(inputArray[arrayIndex - 1], subArrayIndex)\n    );\n  }\n\n  // bottom diagonal neighbours\n  if (inputArray[arrayIndex + 1] !== undefined) {\n    neighbours.push(\n      getNeighboursByIndex(inputArray[arrayIndex + 1], subArrayIndex)\n    );\n  }\n\n  //vertical neighbours\n  neighbours.push(getVerticalNeighbours(inputArray, arrayIndex, subArrayIndex));\n  return neighbours\n    .toString()\n    .split(\",\")\n    .map(x => +x)\n    .sort();\n};\n\nconst countAliveNeighboursOfCell = function(\n  inputArray,\n  arrayIndex,\n  subArrayIndex\n) {\n  return getAllNeighbours(inputArray, arrayIndex, subArrayIndex).filter(x => x)\n    .length;\n};\n\nconst isAlive = function(aliveNeighbours, currentState) {\n  if (aliveNeighbours < 2 || aliveNeighbours > 3) {\n    return 0;\n  }\n  if (aliveNeighbours === 3) {\n    return 1;\n  }\n  return currentState;\n};\n\nconst runIteration = function(inputArray) {\n  let result = inputArray.map(x => x.slice());\n\n  inputArray.forEach((elemOfArray, count) => {\n    inputArray[count].forEach((elem, index) => {\n      let totalAlive = countAliveNeighboursOfCell(inputArray, count, index);\n      let state = isAlive(totalAlive, inputArray[count][index]);\n      result[count][index] = state;\n    });\n  });\n\n  return result;\n};\n\nconst toggleState = function(inputArray, arrayIndex, subArrayIndex) {\n  let result = inputArray.slice();\n  let currentState = result[arrayIndex][subArrayIndex];\n  currentState = 1 - currentState;\n  result[arrayIndex][subArrayIndex] = currentState;\n  return result;\n};\n\nconst world = function(height, length, resurrectCells) {\n  let result = generateGrid(height, length);\n  let arrayIndex = resurrectCells.map(x => x[0]);\n  let subIndex = resurrectCells.map(x => x[1]);\n  for (let count = 0; count < arrayIndex.length; count++) {\n    result = toggleState(result, arrayIndex[count], subIndex[count]);\n  }\n  return result;\n};\n\nconst getCoordOfAliveCells = function(world) {\n  let result = [];\n  for (let count = 0; count < world.length; count++) {\n    for (let index = 0; index < world[count].length; index++) {\n      if (world[count][index] === 1) {\n        result.push([count, index]);\n      }\n    }\n  }\n  return result;\n};\nconst validateOutput = function(bound, aliveCellsCoordinate) {\n  let result = aliveCellsCoordinate.map(x => x.slice());\n\n  result = result.map(function(x) {\n    return x.map((number, index) => (index === 0 ? number + this : number));\n  }, bound.topLeft[0]);\n\n  result = result.map(function(x) {\n    return x.map((number, index) => (index === 1 ? number + this : number));\n  }, bound.topLeft[1]);\n\n  return result;\n};\n\nconst validateInput = function(bound, aliveCellsCoordinate) {\n  let result = filterValidGeneration(bound, aliveCellsCoordinate);\n  result = result.map(x => x.slice());\n\n  result = result.map(function(x) {\n    return x.map((number, index) => (index === 0 ? number - this : number));\n  }, bound.topLeft[0]);\n\n  result = result.map(function(x) {\n    return x.map((number, index) => (index === 1 ? number - this : number));\n  }, bound.topLeft[1]);\n\n  return result;\n};\n\nconst filterValidGeneration = function(bounds, currGeneration) {\n  const isValid = function(elem) {\n    return elem >= bounds.topLeft[this] && elem <= bounds.bottomRight[this];\n  };\n\n  const checkValidHeight = isValid.bind(0);\n  const checkValidWidth = isValid.bind(1);\n\n  const checkValidDimensions = function(subArray) {\n    return checkValidHeight(subArray[0]) && checkValidWidth(subArray[1]);\n  };\n\n  return currGeneration.filter(checkValidDimensions);\n};\n\n/* ------- EXPORTS ------- */\n\nmodule.exports = {\n  repeat,\n  generateDeadCells,\n  generateGrid, //\n  getNeighboursByIndex,\n  getHorizontalNeighbours,\n  getVerticalNeighbours,\n  getAllNeighbours,\n  countAliveNeighboursOfCell,\n  isAlive,\n  toggleState,\n  runIteration,\n  world,\n  getCoordOfAliveCells,\n  validateInput,\n  validateOutput\n};\n","const {\n  runIteration,\n  world,\n  getCoordOfAliveCells,\n  validateInput,\n  validateOutput\n} = require(\"./library.js\");\n\nconst nextGeneration = function(currGeneration, bounds) {\n  let result = [];\n  let heightOfWorld = bounds.bottomRight[1] - bounds.topLeft[1] + 1;\n  let lengthOfWorld = bounds.bottomRight[0] - bounds.topLeft[0] + 1;\n  result = world(\n    lengthOfWorld,\n    heightOfWorld,\n    validateInput(bounds, currGeneration)\n  );\n  result = runIteration(result);\n  return validateOutput(bounds, getCoordOfAliveCells(result));\n};\n\nexport default nextGeneration;\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport nextGeneration from \"./gameOfLife.js\";\n\nclass GameOfLife extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      currentGeneration: [],\n      bounds: { topLeft: [0, 0], bottomRight: [9, 9] },\n      previousGen: [],\n      nextGen: nextGeneration.bind(this),\n      grid: [],\n      interval: \"\"\n    };\n  }\n  updateCurrentGeneration(currentCell) {\n    let cell = JSON.parse(currentCell);\n    if (!this.state.currentGeneration.includes(cell)) {\n      this.state.currentGeneration.push(cell);\n      return;\n    }\n    const position = this.state.currentGeneration.indexOf(cell);\n    this.state.currentGeneration.splice(position);\n  }\n\n  makeCellAlive(e) {\n    const cell = e.target.id;\n    let color = \"green\";\n    const cellStyle = document.getElementById(cell).style;\n    if (cellStyle.backgroundColor === color) {\n      color = \"white\";\n    }\n    cellStyle.backgroundColor = color;\n    this.updateCurrentGeneration(cell);\n  }\n\n  createRow(row) {\n    let currentRow = [];\n    for (let column = 0; column < this.state.bounds.bottomRight[1]; column++) {\n      let ids = \"[\" + row + \",\" + column + \"]\";\n      currentRow.push(<td id={ids} onClick={this.makeCellAlive.bind(this)} />);\n    }\n    return currentRow;\n  }\n\n  createTable(row) {\n    let table = [];\n    for (let row = 0; row < this.state.bounds.bottomRight[0]; row++) {\n      table.push(<tr>{this.createRow(row)}</tr>);\n    }\n    return table;\n  }\n\n  clearPreviousCellsStyling() {\n    this.state.previousGen.forEach(cell => {\n      let ele = document.getElementById(JSON.stringify(cell));\n      if (ele !== null) ele.style.backgroundColor = \"white\";\n    });\n  }\n  clearCurrentCellsStyling() {\n    this.state.currentGeneration.forEach(cell => {\n      let ele = document.getElementById(JSON.stringify(cell));\n      if (ele !== null) ele.style.backgroundColor = \"white\";\n    });\n  }\n\n  updateCellsOnBoard() {\n    this.clearPreviousCellsStyling();\n    const cells = this.state.currentGeneration;\n    cells.forEach(cell => {\n      let ele = document.getElementById(JSON.stringify(cell));\n      console.log(\"cell is\", cell);\n      if (ele !== null) ele.style.backgroundColor = \"green\";\n    });\n  }\n\n  startGame() {\n    if (this.state.interval !== \"\") {\n      return null;\n    }\n    const interval = setInterval(() => {\n      this.setState(state => {\n        let result = [];\n        result = this.state.nextGen(state.currentGeneration, state.bounds);\n        state.previousGen = state.currentGeneration;\n        state.currentGeneration = result;\n      });\n      this.updateCellsOnBoard();\n    }, 1000);\n    this.setState(state => {\n      state.interval = interval;\n    });\n  }\n  resetGame() {\n    clearInterval(this.state.interval);\n    this.setState(state => {\n      state.interval = \"\";\n    });\n    this.clearPreviousCellsStyling();\n    this.clearCurrentCellsStyling();\n  }\n\n  aboutGame() {\n    window.location = \"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\";\n  }\n\n  render() {\n    return (\n      <div className=\"board\">\n        <table className=\"table\">\n          <tbody>{this.createTable()}</tbody>\n        </table>\n        <button className=\"game-btn\" onClick={this.startGame.bind(this)}>\n          Start Game\n        </button>\n        <button className=\"game-btn\" onClick={this.resetGame.bind(this)}>\n          Reset Game\n        </button>\n        <button className=\"game-btn\" onClick={this.aboutGame}>\n          About Game\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default GameOfLife;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}